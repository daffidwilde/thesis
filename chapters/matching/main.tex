\chapter{Matching games}
\label{chp:matching}

\graphicspath{{chapters/matching/paper/img/}}

Matching games form a part of game theory that were formally introduced by Gale
and Shapley in their seminal work~\cite{Gale1962}. These games allow for the
allocation of resources and partnerships in a mathematically fair way.
Typically, a matching game is defined by two sets of players (called parties)
that each have preferences over at least some of the elements of the other set.
The objective of the game is then to find a mapping between the sets of players
in which everyone is \emph{happy enough} with their match(es).

This chapter does not contain any novel mathematics, but it does offer an
introduction to matching games and their variants. Studying this branch of
mathematics has contributed to a significant amount of the research conducted
for this thesis, hence its inclusion here. That research has culminated in the
development of a Python library for solving various matching games, \matching.
Among other uses, the \matching\ library proves instrumental in the practical
implementation of the novel method described in Chapter~\ref{chp:kmodes}.

The \matching\ library has been developed as a research tool and adheres to the
best practices discussed in Chapter~\ref{chp:intro}. The current version of
Matching has also been archived on Zenodo under~\doi{10.5281/zenodo.3931026}.
Along with the source code being modularised and fully tested (using example,
integration and property-based unit tests) with 100\% coverage, the library is
documented extensively. Like the \edo\ library developed for the work in
Chapter~\ref{chp:edo}, the \matching\ documentation is hosted online at
\href{https://matching.readthedocs.io}{\nolinkurl{matching.readthedocs.io}}.
The documentation has been written to maximise its effect as a resource for
learning about matching games as well as for the software itself. Furthermore,
the library is registered on the Python Package Index:

\begin{usagesh}
> pip install matching
\end{usagesh}

Matching games have applications in many fields where relationships between
rational agents must be managed. Some example applications include: being able
to inform on healthcare finance policy~\cite{Agarwal2017}; helping to reduce the
complexity of automated wireless communication networks~\cite{Bayat2016}; and
education infrastructure~\cite{Chiarandini2019}. Thus, having access to software
implementations of algorithms that are able to solve such games is essential.

The only current adversary to \matching\ is \matchingr~\cite{Tilly2018}.
\matchingr\ is a package written in C++ with an R interface and its content
overlaps well with that of \matching. However, the lack of a Python interface
makes it less relevant to researchers and other users as Python's popularity
grows both in academia and industry.

At the time of writing, the \matching\ library offers facilities to handle and
solve four types of matching game:

\begin{itemize}
    \item The stable marriage problem (SM)~\cite{Gale1962};
    \item The hospital-resident assignment problem
        (HR)~\cite{Gale1962,Roth1984};
    \item The student-project allocation problem (SA)~\cite{Abraham2007};
    \item The stable roommates problem (SR)~\cite{Irving1985}.
\end{itemize}

This chapter will go through the details of the games for SM and HR, the latter
of which is used in Chapter~\ref{chp:kmodes}. A further piece of work conducted
during the production of this thesis that uses SA is provided as an appendix.

\section{The stable marriage problem}

One of the most ubiquitous matching games is the stable marriage problem (SM).
SM describes the problem of finding a bijection between two distinct, equally
sized sets of players that is stable according to the players' preferences. The
notion of stability is broadly similar across all matching games, albeit up to
the context of the game at hand.
Definitions~\ref{def:sm_game}~through~\ref{def:sm_blocking} formally introduce
the components of SM.

\begin{definition}\label{def:sm_game}
    Consider two distinct sets, \(S\) and \(R\), each of size \(N \in \mathbb
    N\). These sets are the players of the game and are referred to as
    \emph{suitors} and \emph{reviewers}, respectively. Each element of \(S\) and
    \(R\) has a strict ranking of the other set's elements associated with it,
    and this ranking is called their \emph{preference list}. The preference
    lists for each player set can be considered as a function which takes an
    element from the set and produces a permutation of the other set's elements:

    \begin{equation}
        f: S \to R^N; \quad g: R \to S^N
    \end{equation}

    This construction of suitors, reviewers and preference lists is called a
    \emph{game} of size \(N\), denoted \((S, R)\), and is used to
    model instances of SM.
\end{definition}

\begin{definition}\label{def:sm_matching}
    Consider a game \((S, R)\). A \emph{matching} \(M\) is any
    bijection between \(S\) and \(R\). If a pair \((s, r) \in S
    \times R\) are matched in \(M\), then that relationship is denoted \(M(s) =
    r\) and, equivalently, \(M^{-1}(r) = s\).

    A matching is considered valid only if every player in \((S, R)\)
    is matched to another player uniquely.
\end{definition}

\begin{definition}\label{def:sm_preference}
    Let \((S, R)\) be an instance of SM, and consider \(s \in S\) and
    \(r, r' \in R\). Then \(s\) \emph{prefers} \(r\) to \(r'\) if \(r\) appears
    before \(r'\) in \(f(s)\). The definition of preference is equivalent for
    reviewers.
\end{definition}

\begin{definition}\label{def:sm_blocking}
    Let \((S, R)\) be an instance of SM and let \(M\) be a matching of \((S,
    R)\). A pair \((s, r) \in S \times R\) is said to \emph{block} \(M\) if:

    \begin{itemize}
        \item \(s\) and \(r\) are not matched by \(M\), i.e. \(M(s) \neq r\);
        \item \(s\) prefers \(r\) to \(M(s) = r'\); and
        \item \(r\) prefers \(s\) to \(M^{-1}(r) = s'\).
    \end{itemize}

    A matching \(M\) is said to be \emph{stable} if it has no blocking pairs,
    and \emph{unstable} otherwise.
\end{definition}

This final definition envelopes the critical differences between the various
matching games in existence. Despite their differences, however, the spirit is
the same: a pair of players blocks a matching if their envy is \emph{mutually
rational}. Irrational envy would be where one player wishes to be matched to
another over their current match but the other player does not (or cannot)
reciprocate. The social outcome of acting irrationally in SM is that a player
would be betraying their partner for another player, thus destabilising the
group, without any reward of a `better' partner.

Consider the game of size three shown in Figure~\ref{fig:sm_matching} as an
edgeless graph with suitors on the left and reviewers on the right. This
representation of a matching game finds it origin in the bipartite matching
problems of graph theory. Beside each vertex is the name of the player and their
associated ranking of the complementary setâ€™s elements.

\begin{figure}[htbp]
    \centering
    \input{chapters/matching/paper/docs/tex/sm_matching}
    \caption{A game of size three}\label{fig:sm_matching}
\end{figure}

In this representation, a matching \(M\) creates a bipartite graph where an edge
between two vertices (players) indicates that they are matched by \(M\).
Figure~\ref{fig:sm_unstable} shows an example of a valid matching.

\begin{figure}[htbp]
    \centering
    \input{chapters/matching/paper/docs/tex/sm_unstable}
    \caption{An unstable matching to the game}\label{fig:sm_unstable}
\end{figure}

In this matching, players \(A\), \(C\) and \(F\) are all matched to their
favourite player while \(B\), \(D\) and \(E\) are matched to their least
favourite. In particular, \(B\) and \(D\) form a blocking pair since they would
both rather be matched to one another than their current match. Hence, this
matching is unstable. As an attempt to rectify this instability, let the matches
for the first two rows swap, as shown in Figure~\ref{fig:sm_stable}. This move
does not form another blocking pair despite \(A\) having a worse match since
\(D\) ranks \(A\) at the bottom of its preference list. Therefore, the envy
exhibited by \(A\) is not reciprocated, and the matching is stable.

\begin{figure}[htbp]
    \centering
    \input{chapters/matching/paper/docs/tex/sm_stable}
    \caption{A stable, suitor-optimal solution to the game}\label{fig:sm_stable}
\end{figure}

Upon closer inspection of this matching, it appears that no suitor can improve
on their current match without forming a blocking pair. In fact, the only suitor
improvement would be for \(A\) and \(D\) to be matched again. This kind of
stable matching is called \emph{suitor-optimal}. Similarly, no reviewer can
improve their match without forming a blocking pair and so this matching is also
\emph{reviewer-optimal}.

Finding a party-optimal, stable matching to an instance of a matching game is
referred to as \emph{solving} the game. When there are only a handful of players
to deal with, solving a game (or even finding a party-suboptimal, stable
matching) is relatively straightforward with pen, paper and some time. However,
solving the example above in two steps was little more than a coincidence,
really. In the seminal paper on matching games~\cite{Gale1962}, Gale and Shapley
presented an algorithm for finding a unique, stable and suitor-optimal matching
to any instance of SM. This algorithm has since become known as the Gale-Shapley
algorithm, and is given in Algorithm~\ref{alg:stable_marriage}. The matching
this algorithm produces is that shown in Figure~\ref{fig:sm_stable}.

\balg%
\caption{The suitor-optimal algorithm for SM}\label{alg:stable_marriage}
\KwIn{%
    a set of suitors \(S\), a set of reviewers \(R\), two preference list
    functions \(f\) and \(g\)
}
\KwOut{%
    a stable, suitor-optimal matching \(M\) between \(S\) and \(R\)
}\vspace{1em}

\For{\(p \in S \cup R\)}{%
    Set player \(p\) to be unmatched
}
\While{there exists an unmatched suitor \(s \in S\)}{%
    Take any such suitor \(s\) and their favourite reviewer \(r\)\;
    \If{\(r\) is matched to some other suitor \(s'\)}{%
        Set \(r\) and \(s'\) to be unmatched\;
    }
    Match \(s\) and \(r\), i.e. \(M(s) \gets r\)\;
    \For{each successor, \(t \in g(r)\), to \(s\)}{%
        \(\textsc{DeletePair}(r, t)\)\;
    }
}
\ealg%

\balg%
\caption{\textsc{DeletePair}}\label{alg:delete}
\KwIn{%
    two players \(p, q\) and their respective party's preference list functions
    \(f, g\)
}
\KwOut{updated preference lists}\vspace{1em}

\(f(p) \gets f(p) \setminus \left\{q\right\}\)\;
\(g(q) \gets g(q) \setminus \left\{p\right\}\)\;
\ealg%

As an instance of SM requires \(S\) and \(R\) to be of equal size, the
reviewer-optimal algorithm is equivalent to Algorithm~\ref{alg:stable_marriage}
with the roles of suitors and reviewers reversed.

Even with the process described in the Gale-Shapley algorithm, solving an
instance of SM soon becomes infeasible to do by hand in good time as the size of
the game increases. Furthermore, instances of other matching games tend to have
more players (and relationships between them) than SM and require the use of
software to be solved in reasonable time. Hence, the development of the
\matching\ library which computes the matching as follows:

\begin{usagepy}
>>> from matching.games import StableMarriage
>>> suitor_preferences = {
...     "A": ["D", "E", "F"], "B": ["D", "F", "E"], "C": ["F", "D", "E"]
... }
>>> reviewer_preferences = {
...     "D": ["B", "C", "A"], "E": ["A", "C", "B"], "F": ["C", "B", "A"]
... }
>>> game = StableMarriage.create_from_dictionaries(
...     suitor_preferences, reviewer_preferences
... )
>>> game.solve()
{A: E, B: D, C: F}

\end{usagepy}

Since the publication of~\cite{Gale1962}, several other matching games have come
into vogue, as well as variants to the fundamental games like SM. However, the
accompanying algorithms for solving these games are still often structured to be
party-oriented and aim to maximise some form of social or party-based
optimality~\cite{Fuku2006,Gale1962,Kwanashie2015}. In turn, these algorithms
tend to follow a similar structure to Algorithm~\ref{alg:stable_marriage}, which
has given the family of such matching game algorithms the name `Gale-Shapley'
algorithms.

A common and valuable extension to SM is the allowing of ties in a preference
list; this is sometimes called indifference. Such an extension is
straightforward enough to implement but the notion of stability becomes tiered;
a matching is one of unstable, weakly stable, super-stable, or strongly
stable~\cite{Irving1994,Iwama2016,Iwama1999}. In each case of stability, if such
a matching exists, then a polynomial-time algorithm will find one that is
optimal for one set of players. However, there is no guarantee that such a
level-of-stable matching exists and, even in that case, the notion of
party-optimality is lost~\cite{Erdil2017}.

Further to allowing ties, how preference lists are constructed is a point of
interest in many applications of matching games~\cite{Iwama2008,Manlove2002}.
Often this is a contextual problem and may be addressed in a number of ways. As
is briefly discussed in Chapter~\ref{chp:kmodes}, bespoke preference list
functions may be derived from some expert knowledge a priori to discourage
particular matchings. Meanwhile, if the game forms part of a larger,
long-standing or otherwise complex model, introducing flexibility in
preferences (as in~\cite{Agarwal2017,Menzel2015}) may be helpful where streaming
information should inform the preference lists. Likewise,~\cite{Rastegari2016}
shows that estimating preference lists on the fly in the absence of complete
information aids obtaining meaningful matchings.


\section{The hospital-resident assignment problem}

In addition to SM,~\cite{Gale1962} presented a game that modelled the college
admission process. Since then, this game has been widely rebranded as the
hospital-resident assignment problem (HR). This rebranding comes from it
providing a practical solution to the problem that gives it its namesake:
assigning medical students to resident positions at hospitals in the United
States. A variant of the algorithm given in this section is used to this day by
the National Resident Matching Program.

HR is, in fact, a generalisation of SM. The game that models HR relaxes the
conditions that the two player parties be the same size, and allows for multiple
concurrent matches by the reviewing party (the hospitals in this case).
Definitions~\ref{def:hr_game}~through~\ref{def:hr_blocking} describe the
components that make up the HR game.

\begin{definition}\label{def:hr_game}
    Consider two distinct sets, \(R\) and \(H\), and refer to them as
    \emph{residents} and \emph{hospitals}. Each hospital \(h \in H\) has a
    capacity \(c_h \in \mathbb{N}\) associated with them. Each player \(r \in
    R\) and \(h \in H\) has associated with them a strict preference list of the
    other party's elements such that:
    
    \begin{itemize}
        \item Each resident \(r \in R\) ranks a non-empty subset of \(H\),
            denoted by \(f(r)\);
        \item Each \(h \in H\) ranks all and only those residents that have
            ranked it, i.e.\ the preference list of \(h\), denoted \(g(h)\), is
            a permutation of the set
            \(\left\{r \in R \ | \ h \in f(r)\right\}\). If no such residents
            exist, \(h\) is removed from \(H\).
    \end{itemize}
    
    This construction of residents, hospitals, capacities and preference lists
    is called a \emph{game} and is denoted by \((R, H)\). The notion of
    preference here is the same as in SM.
\end{definition}

\begin{definition}\label{def:hr_matching}
    Consider a game \((R, H)\). A \emph{matching} \(M\) is any mapping between
    \(R\) and \(H\). If a pair \((r, h) \in R \times H\) are matched in \(M\)
    then this relationship is denoted \(M(r) = h\) and \(r \in M^{-1}(h)\).
    A matching is only considered \emph{valid} if all of the following hold for
    all \(r \in R, h \in H\):
    \begin{itemize}
        \item If \(r\) is matched then \(M(r) \in f(r)\).
        \item If \(h\) has at least one match then \(M^{-1}(h) \subseteq g(h)\).
        \item \(h\) is not over-subscribed, i.e.\ \(\abs*{M^{-1}(h)} \leq c_h\).
    \end{itemize}
    A valid matching is considered \emph{stable} if it does not contain any
    blocking pairs.
\end{definition}

\begin{definition}\label{def:hr_blocking}
    Consider a game \((R, H)\). Then a pair \((r, h) \in R \times H\) is said to
    \emph{block} a matching \(M\) if all of the following hold:
    \begin{itemize}
        \item There is mutual preference, i.e.\ \(r \in g(h)\) and \(h \in
            f(r)\).
        \item Either \(r\) is unmatched or they prefer \(h\) to \(M(r)\).
        \item Either \(h\) is under-subscribed or \(h\) prefers \(r\) to at
            least one resident in \(M^{-1}(h)\).
    \end{itemize}
\end{definition}

Like SM, there exists an algorithm that can provide a unique, party-optimal,
stable matching to any instance of HR.\ The resident-optimal algorithm is
presented in Algorithm~\ref{alg:hospital_resident} and is adapted from the
original to take advantage of the structure of the game~\cite{Roth1984}. The
game used to model HR, its matchings, and its notion of stability are defined in
Definitions~\ref{def:game}---\ref{def:blocking}.

Another method used to construct preference lists is to discount the preference
lists presented by players. For instance, where acceptability of another player
is the only criterion, binary preferences (i.e.\ incomplete preference lists
with ties) can create games that are invulnerable to manipulative players'
strategies~\cite{Bogomolnaia2004}. This approach can be adapted to cater for
larger games, such as student-school allocation (a special case of HR). In this
scenario, each student submits a set of acceptable schools and the schools form
strict rankings of the students. The result of this is a simpler game (in the
practical sense) and a reduction in the set of possible stable
matchings~\cite{Haeringer2014,Haeringer2019}.


